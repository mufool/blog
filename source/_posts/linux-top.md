---
layout: post
title: top命令详解
date: 2016-07-13 16:32:04
tags: [LINUX]
---

top命令算是最直观、好用的查看服务器负载的命令了。它实时动态刷新显示服务器状态信息，且可以通过交互式命令自定义显示内容，非常强大。

<!-- more -->

在终端中输入top，回车后会显示如下内容：

```
	top - 17:25:46 up 44 days,  4:32,  8 users,  load average: 0.14, 0.09, 0.03
	Tasks: 142 total,   1 running, 141 sleeping,   0 stopped,   0 zombie
	Cpu(s):  0.3%us,  0.4%sy,  0.0%ni, 98.8%id,  0.0%wa,  0.0%hi,  0.0%si,  0.4%st
	Mem:   6982184k total,  6632640k used,   349544k free,   276936k buffers
	Swap:  4194296k total,   285776k used,  3908520k free,  5641168k cached

	PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
	 27 root      20   0 15036 1220  900 R  0.3  0.0   0:00.04 top
	  1 root      20   0 19232  544  352 S  0.0  0.0   0:00.71 init
	  2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd
	  3 root      RT   0     0    0    0 S  0.0  0.0   0:10.39 migration/0
```

## 系统信息统计

前五行是系统整体状态的统计信息展示区域。下面分别介绍每一行中的内容：

1. 第一行显示服务器概况

	如下所示，第一行列出了服务器运行了多长时间，当前有多少个用户登录，服务器的负荷情况等，使用uptime命令能获得同样的结果

	```
	top - 21:48:39 up  8:57,  2 users,  load average: 0.36, 0.24, 0.14
			/         /        /                \
	当前时间  运行时长   当前登录用户数  平均负载（1分钟、5分钟、15分钟）
	```

	平均负载的值越小代表系统压力越小，越大则代表系统压力越大。通常，我们会以最后一个数值，也就是15分钟内的平均负载作为参考来评估系统的负载情况。
	对于只有单核cpu的系统，1.0是该系统所能承受负荷的边界值，大于1.0则有处理需要等待。一个单核cpu的系统，平均负载的合适值是0.7以下。如果负载长期徘徊在1.0，则需要考虑马上处理了。超过1.0的负载，可能会带来非常严重的后果。当然，多核cpu的系统是在前述值的基础上乘以cpu内核的个数。如对于多核cpu的系统，有N个核则所能承受的边界值为N.0。详见：[理解Linux系统负荷](http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html)和[理解load average](http://blog.chinaunix.net/uid-43607-id-223203.html)

2. 第二行是进程信息：

	```
	Tasks: 322 total,   2 running, 320 sleeping,   0 stopped,   0 zombie
			/                /            /             /            /
		进程总数      正运行进程数    睡眠进程数   停止进程数    僵尸进程数
	```

3. 第三行是CPU信息：

	```
	%Cpu(s):
	5.0 us      用户空间CPU占比
	1.7 sy      内核空间CPU占比
	0.0 ni      用户进程空间改过优先级的进程CPU占比
	93.0 id     空闲CPU占比
	0.0 wa      待输入输出CPU占比
	0.3 hi      硬中断（Hardware IRQ）CPU占比
	0.0 si      软中断（Software Interrupts）CPU占比
	0.0 st      -
	```

	百分比计算方式，比如一秒内有100个cpu时间片，这个cpu时间片就是cpu工作的最小单位。那么这100个cpu时间片在不同的区域和目的进行操作使用，就代表这个区域所占用的cpu时间比。也就是这里得出的cpu时间百分比。

	将文件从磁盘的src位置拷贝到磁盘的dst位置。文件会从src先读取进入到内核空间，然后再读取到用户空间，然后拷贝数据到用户空间的buf上，再通过用户空间，内核空间，数据才到磁盘的dst上。所以从上面这个程序来看，cpu消耗在kernel space的时候就是sy（系统态使用的cpu百分比），cpu消耗在user space的时候就是us（用户态使用的cpu百分比）。

	如果程序都没什么问题，那么是没有hi和si的，但是实际上有个硬中断和软中断的概念。比如硬中断，cpu在执行程序的时候，突然外设硬件（比如硬盘出现问题了）机器需要立刻通知cpu进行现场保存工作。这个时候会cpu会出现上下文切换。就是cpu会有一部分时间会被硬中断占用了，这个时间就是hi。相类似，si是软中断的cpu占用时间，软中断是由软件的指令方式触发的。

	ni是nice的意思，nice是什么呢，每个linux进程都有个优先级，优先级高的进程有优先执行的权利，这个叫做pri。进程除了优先级外，还有个优先级的修正值。即比如你原先的优先级是20，然后修正值为-2，那么你最后的进程优先级为18。这个修正值就叫做进程的nice值。那么nice是一个进程的优先级修正值，为什么会占用cpu时间呢？ni是指用做nice加权的进程使用的用户态cpu时间比，我的理解就是一个进程的所谓修正值就意味着多分配一些cpu时间给这个进程的用户态，这个中间所多分配的cpu时间就是我们这里的ni。

	wa指的是CPU等待磁盘写入完成的时间，就是说前提是要进行IO操作，在进行IO操作的时候，CPU等待时间。比如上面那个程序，最后一步，从系统空间到dst硬盘空间的时候，如果程序是阻塞的，那么这个时候cpu就要等待数据写入磁盘才能完成写操作了。所以这个时候cpu等待的时间就是wa。所以如果一台机器看到wa特别高，那么一般说明是磁盘IO出现问题，可以使用iostat等命令继续进行详细分析。

	st的名字很生动，偷取。。。是专门对虚拟机来说的，一台物理是可以虚拟化出几台虚拟机的。在其中一台虚拟机上用top查看发现st不为0，就说明本来有这么多个cpu时间是安排给我这个虚拟机的，但是由于某种虚拟技术，把这个cpu时间分配给了其他的虚拟机了。这就叫做偷取。

	剩下的id就是除了上面那么多cpu处理上下文以外的cpu时间片。当然在这些时间片上，cpu是空闲的。

	top的所有这些cpu时间应该是相加为100%的。

4. 第四行是内存信息：

	```
	KiB Mem:   1010504 total,   937416 used,    73088 free,    23708 buffers
	                /                /                /                /
	            物理内存总量      使用中总量        空闲总量        缓存的内存量
	```

	内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。

5. 第五行是swap交换分区信息：

	```
	KiB Swap:  1046524 total,   280708 used,   765816 free,   365556 cached Mem
				/                /                /                /
			交换区总量      使用中总量        空闲总量        缓存的内存量
	```

	程序可用内存数：Memfree + (buffers + cached)
	程序已用内存数：Memused – (buffers + cached)

	如果你的 swap used 数值大于 0 ，基本可以判断已经遇到内存瓶颈了，要么优化你的代码，要么加内存。

	buffers是用来存储，目录里面有什么内容，权限等等。而cached直接用来记忆我们打开的文件，如果你想知道他是不是真的生效，你可以试一下，先后执行两次cat 一个比较大的日志文件，比如nginx的access.log，你就可以明显的感觉到第二次的开打的速度快很多。

	因为Linux将你暂时不使用的内存作为文件和数据缓存，以提高系统性能，当你需要这些内存时，系统会自动释放（不像windows那样，即使你有很多空闲内存,他也要访问一下磁盘中的pagefiles）

## 进程（任务）状态监控

第七行及以下显示了各进程（任务）的状态监控。各列所代表的含义如下：

```
	PID         进程id
	USER        进程所有者
	PR          进程优先级
	NI          nice值。负值表示高优先级，正值表示低优先级
	VIRT        进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
	RES         进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
	SHR         共享内存大小，单位kb
	S           进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
	%CPU        上次更新到现在的CPU时间占用百分比
	%MEM        进程使用的物理内存百分比
	TIME+       进程使用的CPU时间总计，单位1/100秒
	COMMAND     进程名称（命令名/命令行）
```

## 交互命令

```
	h或者? 显示帮助画面，给出一些简短的命令总结说明。
	k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。
	i 忽略闲置和僵死进程。这是一个开关式命令。
	q 退出程序。
	r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。
	S 切换到累计模式。
	s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。
	f或者F 从当前显示中添加或者删除项目。
	o或者O 改变显示项目的顺序。
	l 切换显示平均负载和启动时间信息。
	m 切换显示内存信息。
	t 切换显示进程和CPU状态信息。
	c 切换显示命令名称和完整命令行。
	M 根据驻留内存大小进行排序。
	P 根据CPU使用百分比大小进行排序。
	T 根据时间/累计时间进行排序。
	W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。
```

## top常用命令

```
	输入大写P，则结果按CPU占用降序排序。
	输入大写M，结果按内存占用降序排序。
	按数字 1 则可以显示所有CPU核心的负载情况。
	top -d 5 每隔 5 秒刷新一次，默认 1 秒
	top -p 4360,4358 监控指定进程
	top -U johndoe ‘U’为 真实/有效/保存/文件系统用户名。
	top -u 500 ‘u’为有效用户标识
	top -bn 1 显示所有进程信息，top -n 1 只显示一屏信息，供管道调用
	top -M  show memory summary in megabytes not kilobytes
	top -p 25097 -n 1 -b  -b 避免输出控制字符，管道调用出现乱码
	top翻页：top -bn1 | less
```

参考：
[http://tabalt.net/blog/linux-top/](http://tabalt.net/blog/linux-top/)
[http://www.51xdn.net/czxt/Linux/20150123/11197.html](http://www.51xdn.net/czxt/Linux/20150123/11197.html)


